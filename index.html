<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Boss Timer</title>
  <style>
    :root{
      --bg:#0b0f14;
      --card:#121926;
      --text:#e7eefc;
      --muted:#a9b9d8;
      --line:rgba(255,255,255,.14);
      --line-strong:rgba(255,255,255,.26);
      --btn:#2b6dff;
      --btn2:rgba(255,255,255,.10);
      --danger:#ff4d4d;
      --danger-bg:rgba(255,77,77,.16);
      --focus:#9bc0ff;
      --active:#2b6dff;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:radial-gradient(1000px 600px at 20% -10%, rgba(43,109,255,.14), transparent 55%),var(--bg);
      color:var(--text);
    }
    .wrap{max-width:1100px;margin:0 auto;padding:18px}
    header.wrap{display:flex;align-items:center;justify-content:space-between;gap:16px;flex-wrap:wrap}
    .title h1{margin:0 0 4px 0;font-size:20px}
    .muted{color:var(--muted)}
    .small{font-size:12px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:14px}
    .card{
      background:rgba(18,25,38,.92);
      border:1px solid var(--line);
      border-radius:12px;
      padding:12px;
      box-shadow:0 8px 20px rgba(0,0,0,.35);
    }
    .span2{grid-column:span 2}
    h2{margin:0 0 10px 0;font-size:16px}
    label{display:block;font-size:12px;color:var(--muted)}
    input,textarea,select{
      margin-top:6px;width:100%;
      padding:8px;border-radius:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.20);
      color:var(--text);
      outline:none;
    }
    textarea{min-height:90px}
    code{color:#cfe1ff}

    /* Buttons: higher contrast + visible focus */
    .btn, .btnGhost, .btnDanger{
      padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:800;
      border:1px solid transparent;
    }
    .btn{
      background:var(--btn); color:white; border-color:rgba(43,109,255,.55);
    }
    .btn:hover{filter:brightness(1.06)}
    .btnGhost{
      background:var(--btn2);
      color:var(--text);
      border-color:var(--line-strong);
    }
    .btnGhost:hover{filter:brightness(1.08)}
    .btnDanger{
      background:var(--danger-bg);
      color:var(--danger);
      border-color:rgba(255,77,77,.45);
    }
    .btnDanger:hover{filter:brightness(1.08)}

    button:focus, a:focus, input:focus, select:focus, textarea:focus{
      outline:2px solid var(--focus);
      outline-offset:2px;
    }

    .list{display:flex;flex-direction:column;gap:8px}
    .item{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:10px;border:1px solid var(--line);background:rgba(0,0,0,.12)}
    .badge{font-size:13px;padding:6px 10px;border-radius:999px;border:1px solid var(--line);color:var(--muted);font-weight:800}
    .badgeActive{color:#fff;border-color:rgba(43,109,255,.7);background:rgba(43,109,255,.14)}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px;border-bottom:1px solid var(--line);text-align:left;vertical-align:middle}
    th{color:var(--muted);font-size:12px}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

    @media (max-width:920px){
      .grid{grid-template-columns:1fr}
      .span2{grid-column:auto}
      header.wrap{flex-direction:column;align-items:flex-start}
    }
  </style>
</head>
<body>
<header class="wrap">
  <div class="title">
    <h1>Boss Timer</h1>
    <p class="muted small">
      Preloaded bosses (once). Edit by countdown only.
      Mini=2h+5m, MVP=3h+5m. ‚ÄúACTIVE‚Äù shown for 3 minutes after spawn.
    </p>
  </div>
  <div class="controls">
    <button id="btnNotifs" class="btn">Enable notifications</button>
    <button id="btnExport" class="btnGhost">Export JSON</button>
    <input id="fileImport" type="file" accept="application/json" style="display:none" />
    <button id="btnImport" class="btnGhost">Import</button>
  </div>
</header>

<div class="wrap" style="padding-top:0">
  <div class="card" style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
    <div>
      <strong>Support this boss timer</strong>
      <div class="muted small">If this tool helps you, consider a small donation üíô</div>
    </div>
    <a class="btn" href="https://paypal.me/trai" target="_blank" rel="noopener noreferrer">Donate with PayPal</a>
  </div>
</div>

<main class="wrap grid">
  <section class="card">
    <h2>Bulk update countdowns</h2>
    <p class="muted small">
      One per line: <code>Name, HH:MM:SS, mvp|mini</code><br/>
      Example: <code>Amon Ra, 00:45:12, mvp</code>
    </p>
    <textarea id="bulk"></textarea>
    <div class="controls" style="margin-top:8px">
      <button id="btnBulk" class="btn" type="button">Import / Update</button>
      <button id="btnClearBulk" class="btnGhost" type="button">Clear</button>
      <button id="btnRestoreDefaults" class="btnGhost" type="button">Restore default boss list</button>
    </div>
  </section>

  <section class="card">
    <h2>Next spawns</h2>
    <div class="controls" style="margin-bottom:8px">
      <label>Horizon (hrs)
        <select id="horizon">
          <option>12</option><option selected>24</option><option>48</option><option>72</option>
        </select>
      </label>
      <label>Tick
        <select id="tick">
          <option value="1000">1s</option>
          <option value="2000">2s</option>
          <option value="500">0.5s</option>
        </select>
      </label>
    </div>
    <div id="nextList" class="list"></div>
  </section>

  <section class="card span2">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
      <h2 style="margin:0">All bosses (edit by countdown)</h2>
      <button id="btnClearAll" class="btnDanger" type="button">Clear all</button>
    </div>
    <div id="tableWrap" style="margin-top:10px"></div>
    <p class="muted small" style="margin-top:10px">
      Type the countdown you see in-game ‚Üí <strong>Apply</strong>.
      Use <strong>Killed</strong> when you kill it (sets to full interval: 2h+5 / 3h+5).
      <strong>-10s</strong> fine tunes.
    </p>
  </section>

  <section class="card span2">
    <h2>Schedule (local times)</h2>
    <div id="schedule" class="list"></div>
  </section>
</main>

<footer class="wrap muted small" style="padding-bottom:30px">
  Best reliability: run locally via <code>python3 -m http.server 8000</code> then open <code>http://localhost:8000</code>
</footer>

<script>
(() => {
  // Stable storage keys (do NOT version these)
  const STORAGE = "boss_timer";
  const SEEDED_KEY = "boss_timer_seeded";
  const NOTIF_LOG = "boss_notif_log";

  const ACTIVE_WINDOW_MS = 3 * 60 * 1000; // 3 minutes

  const $ = (id) => document.getElementById(id);

  const els = {
    bulk: $("bulk"),
    btnBulk: $("btnBulk"),
    btnClearBulk: $("btnClearBulk"),
    btnRestoreDefaults: $("btnRestoreDefaults"),

    nextList: $("nextList"),
    schedule: $("schedule"),
    tableWrap: $("tableWrap"),

    horizon: $("horizon"),
    tick: $("tick"),

    btnNotifs: $("btnNotifs"),
    btnClearAll: $("btnClearAll"),

    btnExport: $("btnExport"),
    btnImport: $("btnImport"),
    fileImport: $("fileImport"),
  };

  function uuid() {
    if (crypto && crypto.randomUUID) return crypto.randomUUID();
    return "id-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
  }

  function migrateStorage() {
    // If new key already exists, do nothing
    if (localStorage.getItem(STORAGE)) return;

    const legacyKeys = [
      "boss_timer_v4",
      "boss_timer_v3",
      "boss_timer_v2",
      "boss_timer_v1"
    ];

    for (const key of legacyKeys) {
      const val = localStorage.getItem(key);
      if (val) {
        localStorage.setItem(STORAGE, val);
        console.log("Migrated data from", key);
        break;
      }
    }
  }

  function loadState() {
    try { return JSON.parse(localStorage.getItem(STORAGE)) || { bosses: [] }; }
    catch { return { bosses: [] }; }
  }

  function saveState() {
    localStorage.setItem(STORAGE, JSON.stringify(state));
  }

  function parseCountdownString(s) {
    const m = String(s).trim().match(/^(\d{1,2}):(\d{2}):(\d{2})$/);
    if (!m) return null;
    const h = +m[1], mm = +m[2], ss = +m[3];
    return ((h * 3600) + (mm * 60) + ss) * 1000;
  }

  function msToHHMMSS(ms) {
    const total = Math.max(0, Math.floor(ms / 1000));
    const h = String(Math.floor(total / 3600)).padStart(2, "0");
    const m = String(Math.floor((total % 3600) / 60)).padStart(2, "0");
    const s = String(total % 60).padStart(2, "0");
    return `${h}:${m}:${s}`;
  }

  function fmtDate(d) {
    return new Date(d).toLocaleString(undefined, {
      weekday: "short", month: "short", day: "2-digit", hour: "2-digit", minute: "2-digit"
    });
  }

  function formatDuration(ms) {
    const total = Math.max(0, Math.floor(ms / 1000));
    const h = Math.floor(total / 3600);
    const m = Math.floor((total % 3600) / 60);
    const s = total % 60;
    if (h > 0) return `${h}h ${m}m ${s}s`;
    if (m > 0) return `${m}m ${s}s`;
    return `${s}s`;
  }

  function escapeHtml(s) {
    return String(s).replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;");
  }

  // New truth: 3h - 1s, 2h - 1s
  function intervalMsForType(type) {
    return (type === "mini")
      ? (2 * 60 * 60 * 1000 - 1000)
      : (3 * 60 * 60 * 1000 - 1000);
  }

  function nextSpawnWithInterval(anchorISO, intervalMs, fromDate) {
    const anchor = new Date(anchorISO);
    const from = fromDate || new Date();
    const diff = from.getTime() - anchor.getTime();
    const k = Math.ceil(diff / intervalMs);
    const next = new Date(anchor.getTime() + Math.max(k, 0) * intervalMs);
    return (next.getTime() < from.getTime()) ? new Date(next.getTime() + intervalMs) : next;
  }

  // Default bosses (shown when list is empty)
  const DEFAULT_BOSSES = [
    // MVP
    ["Orc Hero","mvp"],["Maya","mvp"],["Pharaoh","mvp"],["Orc Lord","mvp"],["Doppelganger","mvp"],
    ["Amon Ra","mvp"],["Phreeoni","mvp"],["Mistress","mvp"],["Kraken","mvp"],["Eddga","mvp"],
    // Mini
    ["King Dramoh","mini"],["Dragon Fly","mini"],["Eclipse","mini"],["Mastering","mini"],["Ghostring","mini"],
    ["Toad","mini"],["Deviling","mini"],["Angeling","mini"],["Dark Priest","mini"],["Vagabond Wolf","mini"],
  ];

  // --- State init (ORDER MATTERS) ---
  migrateStorage();
  let state = loadState();

  // Preserve each boss's current "next spawn" while changing interval to the new correct value
  function migrateIntervalsPreserveNext() {
    if (!state?.bosses?.length) return;

    const now = new Date();
    let changed = false;

    for (const b of state.bosses) {
      if (!b.rule) continue;

      const oldIntervalMs =
        (typeof b.rule.intervalMs === "number" && b.rule.intervalMs > 0)
          ? b.rule.intervalMs
          : (typeof b.rule.intervalMinutes === "number" && b.rule.intervalMinutes > 0)
            ? b.rule.intervalMinutes * 60 * 1000
            : null;

      const newIntervalMs = intervalMsForType(b.type);

      // If missing old interval, just set new interval
      if (!oldIntervalMs) {
        b.rule.intervalMs = newIntervalMs;
        delete b.rule.intervalMinutes;
        changed = true;
        continue;
      }

      // Already close enough to new interval
      if (Math.abs(oldIntervalMs - newIntervalMs) < 500) {
        b.rule.intervalMs = oldIntervalMs; // normalize
        delete b.rule.intervalMinutes;
        continue;
      }

      // Preserve the next spawn time based on the OLD interval
      const next = nextSpawnWithInterval(b.rule.anchorISO, oldIntervalMs, now);

      // Switch to NEW interval but keep the same next spawn (no visible reset)
      b.rule.anchorISO = next.toISOString();
      b.rule.intervalMs = newIntervalMs;
      delete b.rule.intervalMinutes;
      changed = true;
    }

    if (changed) saveState();
  }

  // Seed defaults if empty (even if seeded flag exists)
  function seedDefaultsIfNeeded() {
    if (!state.bosses || state.bosses.length === 0) {
      const nowISO = new Date().toISOString();
      state.bosses = DEFAULT_BOSSES.map(([name, type]) => ({
        id: uuid(),
        name,
        type,
        notifyLead: 10,
        rule: { type: "interval", intervalMs: intervalMsForType(type), anchorISO: nowISO }
      }));
      saveState();
    }
    localStorage.setItem(SEEDED_KEY, "1");
  }

  function restoreDefaults() {
    if (!confirm("Restore default boss list? This will replace your current list.")) return;
    const nowISO = new Date().toISOString();
    state.bosses = DEFAULT_BOSSES.map(([name, type]) => ({
      id: uuid(),
      name,
      type,
      notifyLead: 10,
      rule: { type: "interval", intervalMs: intervalMsForType(type), anchorISO: nowISO }
    }));
    saveState();
    renderAll();
  }

  // Next spawn (uses intervalMs; supports legacy intervalMinutes)
  function nextSpawn(boss, from = new Date()) {
    const intervalMs = boss.rule.intervalMs || (boss.rule.intervalMinutes * 60 * 1000);
    return nextSpawnWithInterval(boss.rule.anchorISO, intervalMs, from);
  }

  // Upsert by name+type (bulk import)
  function upsertBossByNameType(name, type, countdownMs, notifyLead) {
    const normName = name.trim().toLowerCase();
    const intervalMs = intervalMsForType(type);
    const anchorISO = new Date(Date.now() + countdownMs).toISOString();

    const existing = state.bosses.find(b => b.name.toLowerCase() === normName && b.type === type);
    if (existing) {
      existing.notifyLead = notifyLead;
      existing.rule.intervalMs = intervalMs;
      delete existing.rule.intervalMinutes;
      existing.rule.anchorISO = anchorISO;
    } else {
      state.bosses.push({
        id: uuid(),
        name: name.trim(),
        type,
        notifyLead,
        rule: { type: "interval", intervalMs, anchorISO }
      });
    }
    saveState();
  }

  // Bulk update
  els.btnBulk.addEventListener("click", () => {
    const raw = els.bulk.value.trim();
    if (!raw) return alert("Paste lines first.");

    const lines = raw.split("\n").map(l => l.trim()).filter(Boolean);
    let updated = 0, skipped = 0;

    for (const line of lines) {
      const parts = line.split(",").map(p => p.trim());
      if (parts.length !== 3) { skipped++; continue; }

      const [name, hhmmss, typeRaw] = parts;
      const type = (typeRaw.toLowerCase() === "mini") ? "mini" : "mvp";
      const ms = parseCountdownString(hhmmss);
      if (ms == null || !name.trim()) { skipped++; continue; }

      upsertBossByNameType(name, type, ms, 10);
      updated++;
    }

    els.bulk.value = "";
    renderAll();
    alert(`Updated: ${updated} | Skipped: ${skipped}`);
  });

  els.btnClearBulk.addEventListener("click", () => els.bulk.value = "");
  els.btnRestoreDefaults.addEventListener("click", restoreDefaults);

  // Row actions
  function applyCountdown(id) {
    const input = els.tableWrap.querySelector(`input.cd[data-id="${id}"]`);
    if (!input) return;

    const ms = parseCountdownString(input.value || "");
    if (ms == null) return alert("Countdown must be HH:MM:SS");

    const b = state.bosses.find(x => x.id === id);
    if (!b) return;

    b.rule.anchorISO = new Date(Date.now() + ms).toISOString();
    input.dataset.dirty = "0";
    saveState();
    renderNext(); renderSchedule(); updateCountdownInputs(false);
  }

  function minusTen(id) {
    const input = els.tableWrap.querySelector(`input.cd[data-id="${id}"]`);
    if (!input) return;

    const ms = parseCountdownString(input.value || "");
    if (ms == null) return;

    const newMs = Math.max(0, ms - 10000);
    input.value = msToHHMMSS(newMs);

    const b = state.bosses.find(x => x.id === id);
    if (!b) return;

    b.rule.anchorISO = new Date(Date.now() + newMs).toISOString();
    input.dataset.dirty = "0";
    saveState();
    renderNext(); renderSchedule(); updateCountdownInputs(false);
  }

  function killed(id) {
    const b = state.bosses.find(x => x.id === id);
    if (!b) return;
    const intervalMs = b.rule.intervalMs || (b.rule.intervalMinutes * 60 * 1000);
    b.rule.anchorISO = new Date(Date.now() + intervalMs).toISOString();
    saveState();
    renderNext(); renderSchedule(); updateCountdownInputs(false);
  }

  function removeBoss(id) {
    if (!confirm("Remove this boss from your list?")) return;
    state.bosses = state.bosses.filter(b => b.id !== id);
    saveState();
    renderAll();
  }

  // NEXT SPAWNS with ACTIVE window
  function renderNext() {
    const now = new Date();

    const items = state.bosses.map(b => {
      const intervalMs = b.rule.intervalMs || (b.rule.intervalMinutes * 60 * 1000);
      const next = nextSpawn(b, now);

      const last = new Date(next.getTime() - intervalMs);
      const activeUntil = new Date(last.getTime() + ACTIVE_WINDOW_MS);
      const isActive = now >= last && now < activeUntil;

      return {
        b,
        next,
        isActive,
        activeRemainingMs: isActive ? (activeUntil.getTime() - now.getTime()) : 0,
        msToNext: next.getTime() - now.getTime(),
      };
    });

    items.sort((a, b) => {
      if (a.isActive && !b.isActive) return -1;
      if (!a.isActive && b.isActive) return 1;
      if (a.isActive && b.isActive) return a.activeRemainingMs - b.activeRemainingMs;
      return a.msToNext - b.msToNext;
    });

    if (items.length === 0) {
      els.nextList.innerHTML = `<p class="muted">No bosses in your list. Restore defaults to start.</p>`;
      return;
    }

    els.nextList.innerHTML = items.map(it => {
      const badge = it.isActive
        ? `<div class="badge badgeActive">ACTIVE</div>`
        : `<div class="badge">${escapeHtml(formatDuration(it.msToNext))}</div>`;

      const subline = it.isActive
        ? `<div class="muted small">Active window: ~${escapeHtml(formatDuration(it.activeRemainingMs))} left ‚Ä¢ Next cycle: ${escapeHtml(fmtDate(it.next))}</div>`
        : `<div class="muted small">Next: ${escapeHtml(fmtDate(it.next))}</div>`;

      return `
        <div class="item">
          <div>
            <strong>${escapeHtml(it.b.name)}</strong>
            ${subline}
          </div>
          ${badge}
        </div>
      `;
    }).join("");
  }

  function renderSchedule() {
    const now = new Date();
    const hrs = parseInt(els.horizon.value, 10);
    const end = new Date(now.getTime() + hrs * 3600 * 1000);

    const all = [];
    for (const b of state.bosses) {
      let t = nextSpawn(b, now);
      let safety = 0;
      while (t <= end && safety++ < 500) {
        all.push({ b, t });
        t = nextSpawn(b, new Date(t.getTime() + 1000));
      }
    }
    all.sort((a, b) => a.t - b.t);

    if (all.length === 0) {
      els.schedule.innerHTML = `<p class="muted">No upcoming spawns in this window.</p>`;
      return;
    }

    els.schedule.innerHTML = all.map(it => `
      <div class="item">
        <div>
          <strong>${escapeHtml(it.b.name)}</strong>
          <div class="muted small">${escapeHtml(fmtDate(it.t))}</div>
        </div>
        <div class="badge">${it.b.notifyLead}m lead</div>
      </div>
    `).join("");
  }

  function renderTable() {
    if (!state.bosses || state.bosses.length === 0) {
      els.tableWrap.innerHTML = `<p class="muted">No bosses. Click ‚ÄúRestore default boss list‚Äù.</p>`;
      return;
    }

    const rows = state.bosses.map(b => {
      const intervalMs = b.rule.intervalMs || (b.rule.intervalMinutes * 60 * 1000);
      const hrs = (intervalMs / (60 * 60 * 1000)).toFixed(2).replace(/\.00$/, "");

      return `
        <tr>
          <td>
            <strong>${escapeHtml(b.name)}</strong>
            <div class="muted small">${escapeHtml(b.type.toUpperCase())} ‚Ä¢ every ${hrs}h</div>
          </td>
          <td>${b.notifyLead} min</td>
          <td style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
            <input class="cd" data-id="${b.id}" inputmode="numeric" placeholder="HH:MM:SS" style="width:120px" />
            <button class="btnGhost minus10" data-id="${b.id}" type="button">-10s</button>
            <button class="btnGhost killed" data-id="${b.id}" type="button">Killed</button>
            <button class="btn apply" data-id="${b.id}" type="button">Apply</button>
            <button class="btnDanger del" data-id="${b.id}" type="button">Remove</button>
          </td>
        </tr>
      `;
    }).join("");

    els.tableWrap.innerHTML = `
      <table>
        <thead><tr><th>Boss</th><th>Notify</th><th>Countdown controls</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    `;

    updateCountdownInputs(true);

    els.tableWrap.querySelectorAll("button.apply").forEach(btn =>
      btn.addEventListener("click", () => applyCountdown(btn.dataset.id))
    );
    els.tableWrap.querySelectorAll("button.minus10").forEach(btn =>
      btn.addEventListener("click", () => minusTen(btn.dataset.id))
    );
    els.tableWrap.querySelectorAll("button.killed").forEach(btn =>
      btn.addEventListener("click", () => killed(btn.dataset.id))
    );
    els.tableWrap.querySelectorAll("button.del").forEach(btn =>
      btn.addEventListener("click", () => removeBoss(btn.dataset.id))
    );

    els.tableWrap.querySelectorAll("input.cd").forEach(inp => {
      inp.addEventListener("input", () => inp.dataset.dirty = "1");
      inp.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter") {
          ev.preventDefault();
          applyCountdown(inp.dataset.id);
        }
      });
    });
  }

  function updateCountdownInputs(force = false) {
    const now = new Date();
    state.bosses.forEach(b => {
      const input = els.tableWrap.querySelector(`input.cd[data-id="${b.id}"]`);
      if (!input) return;

      if (!force) {
        if (document.activeElement === input) return;
        if (input.dataset.dirty === "1") return;
      }

      const next = nextSpawn(b, now);
      input.value = msToHHMMSS(next.getTime() - now.getTime());
      input.dataset.dirty = "0";
    });
  }

  function renderAll() {
    renderNext();
    renderTable();
    renderSchedule();
  }

  // Notifications
  async function requestNotifs() {
    if (!("Notification" in window)) return alert("Notifications not supported.");
    const p = await Notification.requestPermission();
    alert(p === "granted" ? "Notifications enabled." : "Not enabled.");
  }

  function loadNotifLog() {
    try { return JSON.parse(localStorage.getItem(NOTIF_LOG) || "{}"); }
    catch { return {}; }
  }

  function saveNotifLog(log) {
    localStorage.setItem(NOTIF_LOG, JSON.stringify(log));
  }

  function maybeNotify() {
    if (Notification.permission !== "granted") return;
    const now = new Date();
    const log = loadNotifLog();

    for (const b of state.bosses) {
      const next = nextSpawn(b, now);
      const leadMs = (b.notifyLead || 0) * 60 * 1000;
      if (leadMs <= 0) continue;

      const fireAt = next.getTime() - leadMs;
      const key = `${b.id}|${next.toISOString()}`;

      if (Math.abs(now.getTime() - fireAt) <= 1200 && !log[key]) {
        log[key] = Date.now();
        saveNotifLog(log);
        new Notification(`Boss soon: ${b.name}`, {
          body: `Spawns at ${fmtDate(next)} (in ~${b.notifyLead} min)`,
          tag: key
        });
      }
    }

    // cleanup 7 days
    const cutoff = Date.now() - 7 * 24 * 3600 * 1000;
    let changed = false;
    for (const k in log) {
      if (log[k] < cutoff) { delete log[k]; changed = true; }
    }
    if (changed) saveNotifLog(log);
  }

  // Export / Import
  els.btnExport.addEventListener("click", () => {
    const blob = new Blob([JSON.stringify(state, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "boss-timer.json";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  els.btnImport.addEventListener("click", () => els.fileImport.click());
  els.fileImport.addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const r = new FileReader();
    r.onload = () => {
      try {
        const parsed = JSON.parse(String(r.result));
        if (!parsed || !Array.isArray(parsed.bosses)) throw new Error("Invalid file");
        state = parsed;
        saveState();
        renderAll();
        alert("Imported.");
      } catch (err) {
        alert("Import failed: " + (err && err.message ? err.message : "unknown"));
      } finally {
        e.target.value = "";
      }
    };
    r.readAsText(f);
  });

  // Other UI
  els.btnNotifs.addEventListener("click", requestNotifs);
  els.btnClearAll.addEventListener("click", () => {
    if (!confirm("Clear ALL bosses?")) return;
    state.bosses = [];
    saveState();
    renderAll();
  });

  // Tick
  let timer = null;
  function restartTick() {
    if (timer) clearInterval(timer);
    timer = setInterval(() => {
      renderNext();
      renderSchedule();
      updateCountdownInputs(false);
      maybeNotify();
    }, parseInt(els.tick.value, 10));
  }

  els.tick.addEventListener("change", restartTick);
  els.horizon.addEventListener("change", () => renderSchedule());

  // ---- Boot sequence ----
  migrateIntervalsPreserveNext();  // preserve next spawn while switching to new intervals
  seedDefaultsIfNeeded();          // if empty, restore default list
  renderAll();
  restartTick();
})();
</script>
</body>
</html>
